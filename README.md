# VoltDB


Relational -  модель
VoltDB - название
## Домашняя работа №4
## Цель: 
Научиться разбираться в любой СУБД зная только ее название. 

- ## История развития СУБД

**VoltDB Community Edition 1.0 (май 2010)** — *первый широкодоступный релиз, распространяемый под лицензией GPLv3.*  

**VoltDB 1.2 (октябрь 2010)** — *выпуск под двумя лицензиями: общедоступной (VoltDB Community Edition) и коммерческой (VoltDB Enterprise Edition).*  

**VoltDB 2.0 (сентябрь 2011)** — *высоко-производительная отказоустойчивость, за счет записи журнала выполняемых команд (только в VoltDB Enterprise Edition).*  

**VoltOne (октябрь 2011)** — *это новое имя для односерверной версии VoltDB Enterprise Edition.*

**VoltDB 2.5 (апрель 2012)** — *репликация БД, предоставление репликации и восстановления кластера внутри/между ДЦ (только VoltDB Enterprise Edition).* 

**VoltDB 3.0 (январь 2013)** — *уменьшена длительность выполнения запросов, предложены средства для «живой» смены схемы данных, добавлено больше SQL и предложен высоко-производительный экспорт данных (только VoltDB Enterprise Edition).*  

**VoltDB 4.0 (январь 2014)** — *расширены возможности для аналитики в оперативной памяти и поддержка множества новых SQL, значительно увеличена производительность и пропускная способность при чтении аналитики, увеличения размера работающего Кластера без блокировок, поддержка хранимых процедур на языке Groovy, утилита миграции данных из MySQL, интерактивное обучение наряду с Volt Vanguard сертификацией.*  

**VoltDB 5.0 (январь 2015)** — *включены средства интеграции в Hadoop/Big Data экосистему, включая интеграцию средств экспорта (Kafka; HDFS; HTTP и RabbitMQ) так же как интеграцию средств импорта (Kafka Loader; JDBC Loader; VoltDB Hadoop OutputFormat; Vertica UDx; и поддержка Apache Hive и Apache Pig.) VoltDB 5.0 также включает дополнительную поддержку SQL и доступность VoltDB Management Center (веб-браузерная панель для мониторинга и управления конфигурацией.*

**VoltDB 5.1 (март 2015)** — *новая версия функциональности репликации данных, без единой точки отказа.*  

**VoltDB 6.0 (январь 2016)** — *релиз включает поддержку модели данных и запросов гео-пространственных данных, active-active репликацию данных между ДЦ и другие функции.* 


- ### Инструменты для взаимодействия с СУБД

| Команда | Описание |
|----------------|:---------:|
| voltdb | Запускает процесс базы данных VoltDB. Команда voltdb также может собирать файлы журналов для анализа возможных системных ошибок. Команда voltdb запускается локально и не требует работающей базы данных.| 
| voltadmin | Выдает административные команды для работающей базы данных VoltDB. Вы можете использовать voltadmin для сохранения и восстановления моментальных снимков, приостановки и возобновления режима администрирования, а также для отключения базы данных, помимо других задач. Команду voltadmin можно запускать удаленно, она выполняет операции в масштабе всего кластера и требует для подключения работающей базы данных.|
| sqlcmd | Позволяет выполнять SQL-запросы и вызывать хранимые процедуры в интерактивном режиме. Команда sqlcmd удобна для тестирования доступа к базе данных без необходимости написания клиентского приложения. Команду sqlcmd можно запускать удаленно, и для подключения к ней требуется работающая база данных.|



В дополнение к предыдущим инструментам общего назначения VoltDB предоставляет несколько других инструментов для конкретных задач:
| Команда | Описание |
|----------------|:---------:|
|csvloader, jdbcloader и кафкалоадер|Эти утилиты загружают данные из внешних источников в существующую базу данных VoltDB. Они позволяют загружать данные из файлов CSV или текстовых данных, источников данных JDBC или потоков Apache Kafka. Эти команды можно запускать удаленно, и для подключения к ним требуется работающая база данных.|
|snapshotconvert| Преобразует собственные файлы моментальных снимков в CSV или текстовые файлы с вкладками. Команда snapshotconvert полезна при экспорте моментального снимка в собственном формате в текстовые файлы для импорта в другую утилиту обработки данных. (Эта утилита предназначена для устаревших целей. Теперь можно записывать моментальные снимки непосредственно в формат CSV без постобработки, что является рекомендуемым подходом.) Команда snapshotconvert запускается локально и не требует работающей базы данных.|
|snapshotverify| Проверяет, что набор собственных файлов моментальных снимков завершен и действителен. Команда snapshotverify запускается локально и не требует работающей базы данных.|



Наконец, VoltDB включает браузерную консоль управления — VoltDB Management Center — для мониторинга баз данных в режиме реального времени.

http://voltserver:8080/

Центр управления VoltDB обеспечивает графическое отображение ключевых аспектов производительности базы данных, включая пропускную способность, использование памяти, задержку запросов и использование разделов. Чтобы использовать Центр управления, подключитесь к одному из узлов кластера с помощью веб-браузера, указав порт HTTP (по умолчанию 8080), как показано в приведенном выше примере URL. В Центре управления отображаются графики пропускной способности и задержки кластера, а также использования ЦП и памяти для текущего сервера. Вы также можете использовать Центр управления для проверки схемы базы данных и выполнения специальных запросов SQL.

**Коннекторы:**

*python-connector*:  https://github.com/VoltDB/voltdb-client-python

*cpp-connector*:     https://github.com/VoltDB/voltdb-client-cpp

*go-connector*:      https://github.com/VoltDB/voltdb-client-go

*csharp-connector*:  https://github.com/VoltDB/voltdb-client-csharp

*js-connector*:      https://github.com/VoltDB/voltdb-client-nodejs

*php-connector*:     https://github.com/VoltDB/voltdb-client-php

*erlang-connector*:  https://github.com/VoltDB/voltdb-client-erlang


- ## Какой database engine используется в вашей СУБД?

Relational DBMS. In-memory движок. Интерфейс хранимых процедур,
асинхронное/синхронное выполнение хранимых процедур и последовательная
обработка транзакций.  

Каждая VoltDB-база оптимизирована под конкретное приложение посредством шардирования таблиц базы и хранимых процедур, способных взаимодействовать с несколькими шардами на нескольких нодах, что позволяет создать распределенную БД. Поскольку данные и исполнение шардированы, несколько запросов могут исполняться параллельно. Кроме того, поскольку каждая нода работает независимо, каждая траназкция может завершаться без оверхеда в виде блокировки отдельныз записей, которая занимает наибольшее время в исполнении традиционных СУБД.

- ## Как устроен язык запросов в вашей СУБД? Разверните БД с данными и выполните ряд запросов. 

Используется SQL.

Ключом к проектированию доступа к данным для приложений VoltDB является то, что сложный или чувствительный к производительности доступ к базе данных должен осуществляться через хранимые процедуры. К базе данных VoltDB можно выполнять специальные запросы. Однако нерегламентированные запросы не в полной мере выигрывают от оптимизации производительности, на которой специализируется VoltDB, и поэтому их не следует использовать для частых, повторяющихся или сложных транзакций.

В хранимой процедуре вы получаете доступ к базе данных, используя стандартный синтаксис SQL, с такими операторами, как ```SELECT```, ```UPDATE```, ```INSERT``` и ```DELETE```. Вы также можете включить свой собственный код в хранимую процедуру для выполнения вычислений с возвращаемыми значениями, для оценки и выполнения условных операторов или для выполнения многих других функций, которые могут понадобиться вашим приложениям.
 
TODO запросы

- ## Распределение файлов БД по разным носителям?

Поддерживается репликация и шардинг. Шардирование описано на схеме ниже.

**Репликация**
VoltDB поддерживает две формы репликации базы данных:

* Односторонний (пассивный)
* Двусторонний (кросс-центр обработки данных)

*Пассивная репликация* копирует содержимое одной базы данных, называемой главной базой данных, в другую, известную как реплика . При пассивной репликации репликация происходит в одном направлении: от мастера к реплике. Клиенты могут подключаться к базе данных master и выполнять все обычные операции с базой данных, включая операторы ```INSERT```, ```UPDATE``` и ```DELETE```. Как показано на рис. 11.1, изменения «пассивной репликации базы данных» копируются с мастера на реплику. Чтобы обеспечить согласованность между двумя базами данных, реплика запускается как база данных только для чтения, где только транзакции, реплицированные с главной базы, могут изменять содержимое базы данных.

Рисунок 11.1. Пассивная репликация базы данных

*Активная репликация* копирует изменения в обоих направлениях. **Cross Datacenter Replication (XDCR)** можно настроить на нескольких кластерах (а не только на двух). Затем клиентские приложения могут выполнять операции чтения/записи в любом из участвующих кластеров, а изменения в одной базе данных затем копируются и применяются ко всем другим базам данных. 

Рисунок 11.2, «Репликация между центрами обработки данных» показывает, как XDCR может поддерживать клиентские приложения, подключенные к каждому экземпляру базы данных.

Рисунок 11.2. Межцентровая репликация


Репликация базы данных (DR) обеспечивает два ключевых преимущества для бизнеса. 
* Во-первых, это защита ваших бизнес-данных от катастрофических событий, таких как перебои в подаче электроэнергии или стихийные бедствия, которые могут вывести из строя весь кластер. Это часто называют аварийным восстановлением. Поскольку кластеры могут находиться в разных географических точках, как пассивное аварийное восстановление, так и XDCR позволяют другим кластерам продолжать работу без изменений, когда один из них становится неработоспособным. Поскольку реплика доступна для транзакций только для чтения, пассивное аварийное восстановление также позволяет разгрузить рабочие нагрузки только для чтения, такие как создание отчетов, из основного экземпляра базы данных.

* Второй бизнес-проблемой, которую решает аварийное восстановление, является необходимость поддерживать отдельные активные копии базы данных в разных местах. Например, XDCR позволяет хранить копии базы данных товарных запасов на двух или более отдельных складах рядом с приложениями, которым нужны данные. Эта функция позволяет поддерживать огромное количество клиентов, которые не могут поддерживаться одним экземпляром базы данных или могут привести к неприемлемой задержке, когда база данных и пользователи географически разделены. Базы данных могут даже находиться на разных континентах.


- ## На каких языках программирования написана СУБД?

VoltDB использует два языка: базовый механизм - **C / C ++**, а семантическая обработка **SQL** верхнего уровня, управление параллелизмом, распределенная кластеризация и другие задачи - все это **Java**. 
Кроме того, некоторые инструменты созданы с использованием **Python, JS** и т.д.

- ## Какие типы индексов поддерживаются в БД? Приведите пример создания индексов.

*Типы индексов: PRIMARY KEY, UNIQUE или ASSUMEUNIQUE*

Используйте ```CREATE INDEX```, чтобы создать индекс для одного или нескольких столбцов таблицы. Используйте ```DROP INDEX```, чтобы удалить индекс из схемы. В следующем примере схема резервирования рейсов изменяется путем добавления индекса в таблицу Flight для повышения производительности при поиске рейсов.
```$ sqlcmd
1> CREATE INDEX flightTimeIdx ON Flight (departtime);
```
Оператор ```CREATE INDEX``` явно создает индекс. VoltDB неявно создает индекс, когда вы указываете ограничения таблицы ```UNIQUE```, ```PRIMARY KEY``` или ```ASSUMEUNIQUE```. Используйте оператор ```LTER TABLE```, чтобы добавить или удалить эти ограничения таблицы вместе со связанными с ними индексами.


- ## Как строится процесс выполнения запросов в вашей СУБД?

Основная функция хранимой процедуры — выполнение запросов к базе данных. В **VoltDB** это делается в два этапа:
1. Поставьте запросы в очередь с помощью ```voltQueueSQL()``` функции
2. Выполнить очередь и вернуть результаты с помощью ```voltExecuteSQL()``` функции.

Первым аргументом ```voltQueueSQL()``` является оператор SQL, который необходимо выполнить. Оператор SQL объявляется с использованием специального класса SQLStmtс вопросительными знаками в качестве заполнителей для значений, которые будут вставлены во время выполнения.

Операторы SQL должны быть объявлены как ```final``` и инициализированы во время компиляции, либо при объявлении, либо в конструкторе или статическом инициализаторе. Это позволяет планировщику VoltDB определять оптимальный план выполнения для каждого оператора, когда процедура загружается и объявляется в схеме. Чтобы разрешить повторное использование кода, объекты SQLStmt можно наследовать от родительских классов или создавать из других констант времени компиляции.

- ## Есть ли для вашей СУБД понятие «план запросов»? Если да, объясните, как работает данный этап.

Да, есть. Планировщик выстраивает запрос в стиле MapReduce, то есть делает так, чтобы большая часть вычислений происходила на отдельных нодах кластера.

#### Чтение плана выполнения и оптимизация операторов SQL
*План выполнения* — это упорядоченное представление того, как VoltDB будет выполнять инструкцию. Прочитайте план снизу вверх, чтобы понять порядок его выполнения. Так, например, глядя на оператор SQL ```InsertACSStmt``` в хранимой процедуре ```Initialize``` приложения Voter, мы видим следующий план выполнения для вставки кода города в таблицу area_code_state:
```
RETURN RESULTS TO STORED PROCEDURE
 LIMIT 1
  RECEIVE FROM ALL PARTITIONS
   SEND PARTITION RESULTS TO COORDINATOR
    INSERT into "AREA_CODE_STATE"
     MATERIALIZE TUPLE from parameters and/or literals
```
Как упоминалось ранее, проще всего читать планы снизу вверх. Итак, в этом случае оператор SQL выполняется следующим образом:

- Построение записи на основе входных параметров и/или литеральных значений
- Вставка записи в таблицу
- Поскольку это многораздельная процедура, каждый раздел затем отправляет свои результаты координатору.
- Затем координатор сводит результаты, ограничивает результаты (то есть статус вставки) одной строкой и возвращает это значение хранимой процедуре.

Вы заметите, что строки плана выполнения имеют отступ, чтобы указать приоритет. Например, построение кортежа должно происходить до того, как он будет вставлен в таблицу.
#### Оценка использования индексов

Что делает планы выполнения важными, так это то, что они могут помочь вам оптимизировать ваше приложение базы данных, указывая, где можно улучшить доступ к данным, либо путем изменения индексов, либо путем изменения порядка соединения запросов. Начнем с индексов.

VoltDB использует информацию о столбце секционирования, чтобы определить, какой раздел должен выполнять хранимую процедуру с одним разделом. Однако индекс для доступа к записям в этом столбце не создается автоматически. Так, например, в примере с Hello World, если мы удалим первичный ключ (DIALECT) в таблице HELLOWORLD, план выполнения оператора Select также изменится.

ДО:
```
RETURN RESULTS TO STORED PROCEDURE
 INDEX SCAN of "HELLOWORLD" using its primary key index
  uniquely match (DIALECT = ?0)
```
ПОСЛЕ:
```
RETURN RESULTS TO STORED PROCEDURE
 SEQUENTIAL SCAN of "HELLOWORLD"
  filter by (DIALECT = ?0)
```
Обратите внимание, что первая операция изменена на последовательное сканирование таблицы HELLOWORLD, а не на индексированное сканирование.

#### Оценка порядка таблиц для объединений

Другая информация, которую предоставляют планы выполнения, помимо использования индексов, — это порядок соединения таблиц.

Порядок соединения часто влияет на производительность. Обычно при соединении двух или более таблиц ядро базы данных сначала просматривает таблицу, в которой содержится наименьшее количество совпадающих записей. Таким образом, при рассмотрении других условий требуется меньше сравнений. Однако во время компиляции VoltDB не имеет никакой информации о потенциальном размере отдельных таблиц и должна делать наилучшие предположения, основываясь исключительно на схеме таблицы, запросе и любых определенных индексах.

В случаях, когда вы объединяете несколько таблиц и знаете, каким будет оптимальный порядок соединения, VoltDB позволяет указать порядок соединения как часть определения оператора SQL. Обычно вы объявляете новый класс SQLstmt, указывая только SQL-запрос. Однако вы можете указать второй аргумент, определяющий порядок соединения в виде списка имен таблиц и псевдонимов, разделенных запятыми. Например:

```
public final SQLStmt FindEmpByMgr = new SQLStmt(
    "SELECT dept.dept_name, dept.dept_id, emp.emp_id, " +
    "emp.first_name, emp.last_name, manager.emp_id " +
    "FROM MANAGER, DEPARTMENT AS Dept, EMPLOYEE AS Emp " + 
    "WHERE manager.emp_id=? AND manager.dept_id=dept.dept_id " +
    "AND manager.dept_id=emp.dept_id " +
    "ORDER BY emp.last_name, emp.first_name",
    "manager,dept,emp");
```

- ## Поддерживаются ли транзакции в вашей СУБД? Если да, то расскажите о нем. Если нет, то существует ли альтернатива?

VoltDB ориентированная на обработку транзакций в реальном времени *(OLTP)*, поддерживает выполнение запросов на языке *SQL* и гарантирует транзакционную целостность данных (*ACID*, атомарность и изолированность транзакций).

- ## Какие методы восстановления поддерживаются в вашей СУБД. Расскажите о них.

Безопасность данных в базе данных должна быть наиболее важной проблемой. VoltDB, как база данных в памяти, имеет множество технологических средств для обеспечения надежности данных. VoltDB не использовался в коммерческих приложениях в финансовой сфере, что доказало, что база данных в оперативной памяти VoltDB не имеет проблем с надежностью данных.

#### K-safety:
Данные VoltDB разделены. Установка параметров K-safety (то есть количества синхронизированных копий разделов) может обеспечить стабильность всего кластера. Если K установлено в 1, каждый раздел имеет копию в кластере. Если одна машина выходит из строя, весь кластер VoltDB может работать нормально.

При репликации реплицированный кластер работает независимо и не может помочь, когда выходит из строя только часть активного кластера. Репликация должна вступить во владение только тогда, когда основной кластер базы данных полностью выйдет из строя. Таким образом, в случаях, когда база данных является критически важной, нередко используется как K-безопасность, так и репликация для достижения высочайшего уровня обслуживания.

*Для достижения K=1 необходимо продублировать все разделы.*

(Если вы этого не сделаете, сбой узла, содержащего недублированный раздел, приведет к сбою базы данных.) 

*Аналогично, K=2 требует двух дубликатов каждого раздела и так далее.*

Что происходит во время обычных операций, так это то, что любая работа, назначенная дублированному разделу, отправляется на все копии (как показано на 

Рисунке 10.1, «K-Safety в действии» ). Если узел выходит из строя, база данных продолжает работать, отправляя работу незатронутым копиям раздела.

Рисунок 10.1. K-безопасность в действии

#### Снимок: 
пользователь может установить цикл снимка в соответствии с приложением. VoltDB может сделать снимок данных, а затем записать его на диск, и данные будут существовать постоянно. В случае непредвиденного сбоя VoltDB может выполнять операции восстановления данных на основе файлов моментальных снимков, уже находящихся на диске. Скорость восстановления данных очень высокая. Например, для восстановления более 60 ГБ данных требуется около 2 минут.

#### Ведение журнала команд (журнал команд): 
эта функция уникальна для VoltDB.Она используется со *Snapshot* для записи журнала всех операций записи между двумя моментальными снимками, чтобы гарантировать, что транзакция не будет потеряна. Операция чтения (чтения) не изменяет данные, поэтому они не записываются.

#### Репликация базы данных: 
это функция, которая уже есть в традиционных базах данных. Она заключается в создании точно такой же копии данных в другом месте. Если основной кластер не работает (например, коллективный сбой питания), немедленно переключите службу на вспомогательный кластер. Обычно аффилированные кластеры создаются в физически другой области.

- ## Расскажите про шардинг в вашей конкретной СУБД. Какие типы используются? Принцип работы.

**VoltDB** - это ACID-совместимая реляционная СУБД, которая использует архитектуру *shared nothing*. Shared nothing архитектура означает, что для исполнения запроса в шардированной базе, необходимо исполнить запрос лишь на одной его ноде, что значительно ускоряет работу базы данных. Нет нужды в ручном шардировании, оно происходит автоматически. 


- ## Возможно ли применить термины Data Mining, Data Warehousing и OLAP в вашей СУБД?

В дополнение к поддержке аналитики в реальном времени, VoltDB легко интегрируется с
Инфраструктуры *OLAP* и *Hadoop*, передающие данные в эти среды для глубокого аналитического исследования. 

VoltDB может быть использована для Data Mining, поиска трендов и аномалий в режиме реального времени. VoltDB также легко интегрируется с большим количеством популярных BI-инструментов, предоставляющих информативные realtime-дашборды.

- ## Какие методы защиты поддерживаются вашей СУБД? Шифрование трафика, модели авторизации и т.п.

Когда приложение создает соединение с базой данных VoltDB (используя ClientFactory.clientCreate), оно передает имя пользователя и пароль как часть конфигурации клиента. Эти параметры идентифицируют клиента в базе данных и используются для аутентификации доступа.
Во время выполнения, если аутентификация включена, имя пользователя и пароль, переданные клиентским приложением, проверяются сервером на соответствие пользователям, определенным в файле конфигурации. Если клиентское приложение передает правильную пару имени пользователя и пароля, соединение устанавливается. Когда приложение вызывает хранимую процедуру, разрешения проверяются снова. Если схема определяет, что пользователю назначена роль, имеющая доступ к этой хранимой процедуре, процедура выполняется. В противном случае вызывающему приложению возвращается ошибка.

**Примечание**:

VoltDB использует хэширование, а не шифрование при передаче имени пользователя и пароля между клиентом и сервером. 
 
Чтобы упростить процесс разработки, **VoltDB** предопределяет для вас две роли при включении безопасности: администратор и пользователь. Администратор имеет права *ADMIN*: доступ ко всем функциям, включая интерактивные SQL-запросы, DDL, системные процедуры и пользовательские процедуры. У пользователя есть разрешения *SQL* и *ALLPROC*: доступ к специальному SQL и всем хранимым процедурам по умолчанию и определяемым пользователем.
 
VoltDB хэширует имена пользователей и пароли как на сервере базы данных, так и при передаче их по сети. Однако сама сетевая связь по умолчанию не шифруется. Вы можете включить *Transport Layer Security (TLS)* — рекомендуемое обновление связи Secure Socket Layer (SSL) — для порта HTTP, который влияет на Центр управления **VoltDB** и интерфейс JSON. 


- ## Какие сообщества развивают данную СУБД?  Кто в проекте имеет права на коммит и создание дистрибутива версий?  Расскажите об этих людей и/или компаниях.

VoltDB имеет версию с открытым исходным кодом и бесплатную пробную версию. Существует также коммерческая версия, которая содержит больше функций. Чтобы загрузить, вам необходимо перейти на официальный сайт, чтобы загрузить его самостоятельно. Например, для восстановления данных, ведения журнала команд и других функций требуется коммерческая версия. Для коммерческой версии предоставляется 30-дневная бесплатная пробная версия. Если вы разработчик и хотите изучить исходный код или внести свой вклад в VoltDB, вы также можете настроить Java eclipse для разработки на странице Wiki GitHub.

*Адрес загрузки версии с открытым исходным кодом:* https://github.com/VoltDB/voltdb/releases，

*Открытый исходный код находится на GitHub:* https://github.com/VoltDB/voltdb。

- ## Создайте свои собственные данные для демонстрации работы СУБД. 
- ## Как продолжить самостоятельное изучение языка запросов с помощью демобазы. Если демобазы нет, то создайте ее.
- ## Где найти документацию и пройти обучение

*Бесплатный онлайн-курс видеообучения VoltDB:* http://voltdb.com/resources/volt-university/tutorials/

*Электронная почта поддержки VoltDB:* вы можете отправлять любые вопросы на **support@voltdb.com**

*Документация:* https://docs.voltdb.com/UsingVoltDB/

- ## Как быть в курсе происходящего
 
*Форум сообщества VoltDB:* https://forum.voltdb.com/

*Сайт* www.voltdb.com



